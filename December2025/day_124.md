## December 10, 2025 - Day 124

### What I Worked On:
**Exercism:**  
For this exercise, we were to create a circular buffer, and then have functions for reading, writing, overwriting, and clearing the data. 
I was not positive how to go about this program. I was not familiar with looping around in a list for the circular buffer. I was also not positive how to handle errors with OOP. I asked ChatGPT to tutor me to help me figure it out. However, the code is fairly straightforward, and it wasn't that hard to figure out with a little help on how to get started. 

### Concepts Practiced:  
- OOP
- Raising errors
- Circular lists 
    
### Resources Used:  
- [Exercism.org](https://exercism.org/tracks/python/exercises)
  
### Code: 
```python
#Exercism
class BufferFullException(BufferError):
    """Exception raised when CircularBuffer is full.

    message: explanation of the error.

    """
    def __init__(self, message = "Circular buffer is full"):
        self.message = message
        super().__init__(message)


class BufferEmptyException(BufferError):
    """Exception raised when CircularBuffer is empty.

    message: explanation of the error.

    """
    def __init__(self, message = "Circular buffer is empty"):
        self.message = message
        super().__init__(message)


class CircularBuffer:
    def __init__(self, capacity):
        self.capacity = capacity

        # A list of fixed length filled with [None]
        self.buffer = [None] * capacity 

        # Reads the index of the oldest element 
        self.read_index = 0 

        # Indicates how many elements are in the buffer
        self.size = 0 

    def read(self):
        # If empty
        if self.size == 0:
            raise BufferEmptyException("Circular buffer is empty")

        # Take the value 
        value = self.buffer[self.read_index]

       # Set that slot to None
        self.buffer[self.read_index] = None

        # Move read_index forward by 1 (with wrap-around)
        self.read_index = (self.read_index + 1) % self.capacity 

        # Decrease the size 
        self.size -= 1 

        # Return the value 
        return value 

    def write(self, data):
        # If buffer is full
        if self.size == self.capacity:
            raise BufferFullException("Circular buffer is full")

        # Write to the next empty slot 
        tail_index = (self.read_index + self.size) % self.capacity 

        # Store the data
        self.buffer[tail_index] = data

        #Increase size
        self.size += 1

    def overwrite(self, data):
        # If not full, write like "write" function
        if self.size < self.capacity: 
            tail_index = (self.read_index + self.size) % self.capacity 
            self.buffer[tail_index] = data
            self.size += 1
        else:
            # Overwrite the oldest, size stays the same
            self.buffer[self.read_index] = data 
            self.read_index = (self.read_index + 1) % self.capacity

    def clear(self):
        # Reset everything to empty
        self.buffer = [None] * self.capacity 
        self.read_index = 0 
        self.size = 0
```
